"use strict";(self.webpackChunkfabric_gatsby5=self.webpackChunkfabric_gatsby5||[]).push([[256],{2971:function(e,n,t){t.r(n),t.d(n,{default:function(){return m}});var a=t(1151),c=t(7294),o=t(8948);const l="\n  let _clipboard;\n  function Copy() {\n    // clone what are you copying since you\n    // may want copy and paste on different moment.\n    // and you do not want the changes happened\n    // later to reflect on the copy.\n    canvas\n      .getActiveObject()\n      .clone()\n      .then((cloned) => {\n        _clipboard = cloned;\n      });\n  }\n\n  async function Paste() {\n    // clone again, so you can do multiple copies.\n    const clonedObj = await _clipboard.clone();\n    canvas.discardActiveObject();\n    clonedObj.set({\n      left: clonedObj.left + 10,\n      top: clonedObj.top + 10,\n      evented: true,\n    });\n    if (clonedObj instanceof fabric.ActiveSelection) {\n      // active selection needs a reference to the canvas.\n      clonedObj.canvas = canvas;\n      clonedObj.forEachObject((obj) => {\n        canvas.add(obj);\n      });\n      // this should solve the unselectability\n      clonedObj.setCoords();\n    } else {\n      canvas.add(clonedObj);\n    }\n    _clipboard.top += 10;\n    _clipboard.left += 10;\n    canvas.setActiveObject(clonedObj);\n    canvas.requestRenderAll();\n  }\n\n  // not using addEventListener to avoid cleanup logic in the demo code\n  document.getElementById('copy').onclick = () => Copy();\n  document.getElementById('paste').onclick = () => Paste();\n\n  const canvas = new fabric.Canvas(canvasEl);\n  // create a rectangle object\n  const rect = new fabric.Rect({\n    left: 100,\n    top: 50,\n    fill: '#D81B60',\n    width: 100,\n    height: 100,\n    strokeWidth: 2,\n    stroke: '#880E4F',\n    rx: 10,\n    ry: 10,\n    angle: 45,\n    hasControls: true,\n  });\n\n  canvas.add(rect);\n\n  // create a rectangle object\n  const rect2 = new fabric.Rect({\n    left: 200,\n    top: 50,\n    fill: '#F06292',\n    width: 100,\n    height: 100,\n    strokeWidth: 2,\n    stroke: '#880E4F',\n    rx: 10,\n    ry: 10,\n    angle: 45,\n    hasControls: true,\n  });\n\n  canvas.add(rect2);\n\n  const circle1 = new fabric.Circle({\n    radius: 65,\n    fill: '#039BE5',\n    left: 0,\n  });\n\n  const circle2 = new fabric.Circle({\n    radius: 65,\n    fill: '#4FC3F7',\n    left: 110,\n    opacity: 0.7,\n  });\n\n  const group = new fabric.Group([circle1, circle2], {\n    left: 40,\n    top: 250,\n  });\n\n  canvas.add(group);\n";function s(e){const n=Object.assign({p:"p",span:"span"},(0,a.ah)(),e.components);return c.createElement(c.Fragment,null,c.createElement(n.p,null,"The embedded serialization properties of fabricJS are good enough for a clipboard like implementation. When you want to copy an object, just store to your destination of choice a cloned copy of the object using"),"\n",c.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token keyword">await</span> activeObject<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>'}}),"\n",c.createElement(n.p,null,"You can also decide to leverage serialization and just store in the clipboard the result of ",c.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">activeObject.toObject()</code>'}})," call and then use the ",c.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">fromObject</code>'}})," counterpart to get it back. Unless you are dealing with some mechanism for which live instances can't be transferred around, the choice between the approaches is a matter of preferences.\nBoth approaches safeguard from unwanted mutation by cloning the object on copy and on paste, so that you can do multiple copies and changes to the origin and following copies without fear of mutating the clipboard"),"\n",c.createElement("div",{className:"controls"},c.createElement("p",null,c.createElement("button",{id:"copy"},"Copy Selected Objects")),c.createElement("p",null,c.createElement("button",{id:"paste"},"Paste Selected Objects"))),"\n",c.createElement(o.p,{code:l,canvasId:"test1"},c.createElement("canvas",{width:"600",height:"500",id:"test1"})))}var r=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?c.createElement(n,e,c.createElement(s,e)):s(e)},i=t(4160),d=t(6422),p=t(1202),u=t(6330),b=t(2059);function h(e){let{data:n,pageContext:t,children:a}=e;const{frontmatter:o,mdFile:l}=n.demoPage;return c.createElement(d.Z,null,c.createElement(b.Z,{title:o.title}),c.createElement("nav",{id:"breadcrumb-nav","aria-label":"breadcrumb"},c.createElement(i.rU,{to:"/demos"},"Demos")," > ",c.createElement("span",null,o.title)),c.createElement("h1",null,o.title),c.createElement("article",null,a),c.createElement(p.Z,{relativePath:l.relativePath}),c.createElement(u.Z,{prev:t.prev||{title:"All FabricJS demos",slug:"/demos"},next:t.next}))}function m(e){return c.createElement(h,e,c.createElement(r,e))}}}]);
//# sourceMappingURL=component---src-templates-demo-jsx-content-file-path-src-content-demo-copy-and-paste-index-md-a96c2894f59a84cad1e0.js.map